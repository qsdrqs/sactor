import argparse
import sys
import os

from sactor import Sactor
from sactor import logging as sactor_logging
from sactor import utils

logger = sactor_logging.get_logger(__name__)
from sactor.test_generator import ExecutableTestGenerator, TestGeneratorResult
from sactor.test_runner import ExecutableTestRunner, TestRunnerResult


def add_logging_arguments(parser: argparse.ArgumentParser) -> None:
    parser.add_argument(
        '--log-dir',
        dest='log_dir',
        help='Override log directory (default: {result_dir}/logs).'
    )


def _configure_logging_from_args(config, args, *, result_dir: str | None = None):
    return sactor_logging.configure_logging(
        config,
        result_dir=result_dir,
        log_dir_override=getattr(args, 'log_dir', None),
    )


def parse_translate(parser):
    parser.add_argument(
        'input_file',
        type=str,
        help='The input C file to translate to Rust'
    )

    parser.add_argument(
        'test_command_path',
        help='The path to the json file containing the test commands, need to follow the format specified in the README'
    )

    parser.add_argument(
        '--type',
        choices=['bin', 'lib'],
        required=True,
        help='Whether the target is a binary program or a library'
    )

    parser.add_argument(
        '--config',
        '-c',
        type=str,
        dest='config_file',
        help='The configuration file to use'
    )

    parser.add_argument(
        '--build-dir',
        '-b',
        type=str,
        help='The directory to use for the build process'
    )

    parser.add_argument(
        '--result-dir',
        '-r',
        type=str,
        help='The directory to use for the result process'
    )

    parser.add_argument(
        '--llm-stat',
        '-l',
        type=str,
        help='The path to output the LLM statistics json file, default to {result_dir}/llm_stat.json'
    )

    parser.add_argument(
        '--no-verify',
        action='store_true',
        help='Do not verify the generated Rust code'
    )

    parser.add_argument(
        '--unidiomatic-only',
        action='store_true',
        help='Only translate C code into unidiomatic Rust code, skipping the idiomatic translation'
    )

    parser.add_argument(
        '--idiomatic-only',
        action='store_true',
        help='Only translate C code into idiomatic Rust code, skipping the unidiomatic translation'
    )

    parser.add_argument(
        '--continue-run-when-incomplete',
        action='store_true',
        help=('Continue to run idiomatic translation even when not all unidiomatic translation succeeds.\n'
              'Idiomatic translation will only be run for those functions, structs, etc., with existing unidiomatic translation')
    )

    parser.add_argument(
        '--extra-compile-command',
        type=str,
        help='The extra compile command to use to compile the C code', # TODO: dirty implement, remove this later
    )

    parser.add_argument(
        '--executable-object',
        '-e',
        type=str,
        action='append',
        default=None,
        help='Path to an executable object file or link argument; may be specified multiple times for library targets'
    )

    parser.add_argument(
        '--all-compile-commands',
        '-a',
        type=str,
        default="",
        help="""The complete compile commands for the C source file to be translated, including compiling and linking command lines.
        This can usually be copied from output of `make build`.
        If there are multiple commands, commands should be separated by newlines.
        Example:
        `
        gcc -DHAVE_CONFIG_H -I. -I..  -I../include -I../include  -D_V_SELFTEST -O2 -Wall -Wextra -ffast-math -fsigned-char -g -O2 -MT test_bitwise-bitwise.o -MD -MP -MF .deps/test_bitwise-bitwise.Tpo -c -o test_bitwise-bitwise.o `test -f 'bitwise.c' || echo './'`bitwise.c
        mv -f .deps/test_bitwise-bitwise.Tpo .deps/test_bitwise-bitwise.Po
        /bin/bash ../libtool  --tag=CC   --mode=link gcc -D_V_SELFTEST -O2 -Wall -Wextra -ffast-math -fsigned-char -g -O2   -o test_bitwise test_bitwise-bitwise.o
        `
        """
    )

    parser.add_argument(
        '--compile-commands-file',
        '-C',
        type=str,
        default="",
        help='The compile commands json file for the project, generated by tools like "scan-build" or "bear"'
    )


def parse_run_tests(parser):
    parser.add_argument(
        'test_samples_path',
        type=str,
        help='The path to the test samples output json file'
    )

    parser.add_argument(
        'target',
        help='The target program or library to test'
    )

    parser.add_argument(
        'test_sample_number',
        type=int,
        help='The number (relative to 0) of the test sample to run'
    )

    parser.add_argument(
        '--type',
        choices=['bin', 'lib'],
        required=True,
        help='Whether the target is a binary program or a library'
    )

    parser.add_argument(
        '--config',
        '-c',
        type=str,
        dest='config_file',
        help='The configuration file to use'
    )

    parser.add_argument(
        "--feed-as-args",
        action='store_true',
        default=None,
        help='Only avaliable for binary targets. If set, the test samples will be fed as arguments to the target program. Default set this unless --feed-as-stdin is set.'
    )

    parser.add_argument(
        "--feed-as-stdin",
        action='store_true',
        default=None,
        help='Only avaliable for binary targets. If set, the test samples will be fed to the target program via stdin.'
    )

    parser.add_argument(
        '--save',
        '-s',
        type=str,
        help='The path to save the output json of the test run and the expected output, if the test fails. If not set, the output will not be saved.'
    )


def parse_generate_tests(parser):
    parser.add_argument(
        'input_file',
        type=str,
        help='The input C file to generate tests for'
    )

    parser.add_argument(
        'count',
        type=int,
        help='The number of total test samples expected. This will include the test samples provided in the test_samples_path'
    )

    parser.add_argument(
        '--out-test-sample-path',
        '-os',
        type=str,
        help='The path to the test samples output json file, default to `$PWD/test_task/test_samples.json`'
    )

    parser.add_argument(
        '--out-test-task-path',
        '-ot',
        type=str,
        help='The path to the test task output json file, default to `$PWD/test_task/test_task.json`'
    )

    parser.add_argument(
        '--type',
        choices=['bin', 'lib'],
        required=True,
        help='Whether the target is a binary program or a library'
    )

    parser.add_argument(
        '--config',
        '-c',
        type=str,
        dest='config_file',
        help='The configuration file to use'
    )

    parser.add_argument(
        '--test-samples_path',
        '-s',
        type=str,
        help='The path to the test samples output json file, if any, need to follow the format specified in the README'
    )

    parser.add_argument(
        '--input-document',
        '-i',
        type=str,
        help='The path to the input document file, if any'
    )

    parser.add_argument(
        '--timeout',
        '-t',
        type=int,
        default=60,
        help='The execution timeout in seconds for each test'
    )

    parser.add_argument(
        '--executable',
        '-e',
        type=str,
        default=None,
        help='The path to the executable to test, only required for binary targets. If not set, sactor will try to directly compile the input file'
    )

    parser.add_argument(
        "--feed-as-args",
        action='store_true',
        default=None,
        help='Only avaliable for binary targets. If set, the test samples will be fed as arguments to the target program. Default set this unless --feed-as-stdin is set.'
    )

    parser.add_argument(
        "--feed-as-stdin",
        action='store_true',
        default=None,
        help='Only avaliable for binary targets. If set, the test samples will be fed to the target program via stdin.'
    )


def translate(parser, args):
    is_executable = args.type == 'bin'
    executable_object = args.executable_object
    if isinstance(executable_object, list):
        executable_object = [item for item in executable_object if item]
        if len(executable_object) == 1:
            executable_object = executable_object[0]
        elif len(executable_object) == 0:
            executable_object = None

    if not is_executable and not executable_object:
        parser.error('Executable object must be provided for library targets')

    config = utils.try_load_config(args.config_file)
    result_dir = args.result_dir if args.result_dir else os.path.join(os.getcwd(), "sactor_result")
    _configure_logging_from_args(config, args, result_dir=result_dir)

    sactor = Sactor(
        input_file=args.input_file,
        test_cmd_path=args.test_command_path,
        build_dir=args.build_dir,
        result_dir=result_dir,
        config_file=args.config_file,
        no_verify=args.no_verify,
        unidiomatic_only=args.unidiomatic_only,
        llm_stat=args.llm_stat,
        extra_compile_command=args.extra_compile_command,
        is_executable=is_executable,
        executable_object=executable_object,
        all_compile_commands=args.all_compile_commands,
        compile_commands_file=args.compile_commands_file,
        idiomatic_only=args.idiomatic_only,
        continue_run_when_incomplete=args.continue_run_when_incomplete
    )

    sactor.run()


def run_tests(parser, args):
    config = utils.try_load_config(args.config_file)
    _configure_logging_from_args(config, args)

    if args.type == 'lib':
        if args.feed_as_args is not None:
            parser.error('--feed-as-args is only avaliable for binary targets')
        if args.feed_as_stdin is not None:
            parser.error(
                '--feed-as-stdin is only avaliable for binary targets')

    if args.type == 'bin':
        if args.feed_as_args is None and args.feed_as_stdin is None:
            args.feed_as_args = True
        if args.feed_as_args and args.feed_as_stdin:
            parser.error(
                'Only one of --feed-as-args and --feed-as-stdin can be set yet')

    if args.feed_as_args:
        feed_as_args = True
    else:
        assert args.feed_as_stdin
        feed_as_args = False

    if args.type == 'bin':
        target = os.path.abspath(args.target)
        test_runner = ExecutableTestRunner(
            args.test_samples_path,
            target,
            config_path=args.config_file,
            feed_as_arguments=feed_as_args
        )
        result = test_runner.run_test(args.test_sample_number, args.save)
        if result[0] == TestRunnerResult.PASSED:
            logger.info('✅ Test %d passed successfully!', args.test_sample_number, extra={"plain": True})
            sys.exit(0)
        else:
            logger.error('❌ Test %d failed!', args.test_sample_number, extra={"plain": True})
            logger.error('Diff (-actual +expected):', extra={"plain": True})
            if result[1]:
                logger.error('%s', result[1], extra={"plain": True})
            sys.exit(1)

    elif args.type == 'lib':
        raise NotImplementedError('Library test runner not implemented yet')

    else:
        raise ValueError(f'Invalid type: {args.type}')


def generate_tests(parser, args):
    config = utils.try_load_config(args.config_file)
    _configure_logging_from_args(config, args)

    if args.type == 'lib':
        if args.feed_as_args is not None:
            parser.error('--feed-as-args is only avaliable for binary targets')
        if args.feed_as_stdin is not None:
            parser.error(
                '--feed-as-stdin is only avaliable for binary targets')

    if args.type == 'bin':
        if args.feed_as_args is None and args.feed_as_stdin is None:
            args.feed_as_args = True
        if args.feed_as_args and args.feed_as_stdin:
            parser.error(
                'Only one of --feed-as-args and --feed-as-stdin can be set yet')

    if args.feed_as_args:
        feed_as_args = True
    else:
        assert args.feed_as_stdin
        feed_as_args = False

    if args.out_test_task_path and not args.out_test_task_path.endswith('.json'):
        parser.error('The test task output path should end with .json')

    if args.out_test_sample_path and not args.out_test_sample_path.endswith('.json'):
        parser.error('The test samples output path should end with .json')

    if args.type == 'bin':
        test_generator = ExecutableTestGenerator(
            config_path=args.config_file,
            file_path=args.input_file,
            test_samples=[],  # test samples provided from test_samples_path in command line mode
            test_samples_path=args.test_samples_path,
            executable=args.executable,
            input_document=args.input_document,
            feed_as_arguments=feed_as_args,
        )

        result = test_generator.generate_tests(args.count)
        if result == TestGeneratorResult.SUCCESS:
            logger.info('✅ Tests generated successfully!', extra={"plain": True})
            test_generator.create_test_task(
                args.out_test_task_path,
                args.out_test_sample_path
            )
            sys.exit(0)
        else:
            logger.error('❌ Failed to generate tests', extra={"plain": True})
            sys.exit(1)
    elif args.type == 'lib':
        raise NotImplementedError('Library test runner not implemented yet')

    else:
        raise ValueError(f'Invalid type: {args.type}')


def main():
    logging_parent = argparse.ArgumentParser(add_help=False)
    add_logging_arguments(logging_parent)

    parser = argparse.ArgumentParser(
        description='SACToR: Structure-Aware C To Rust Translator',
        parents=[logging_parent]
    )

    subparsers = parser.add_subparsers(
        dest='subcommand',
        description='valid subcommands for SACToR to work in different modes',
        help='Use one of these subcommands followed by -h for additional help',
        required=True
    )

    translate_parser = subparsers.add_parser(
        'translate',
        help='Translate C code into Rust code',
        parents=[logging_parent]
    )

    test_runner_parser = subparsers.add_parser(
        'run-tests',
        help='Run tests on the target program or library',
        parents=[logging_parent]
    )

    generate_tests_parser = subparsers.add_parser(
        'generate-tests',
        help='Generate tests for the target program or library',
        parents=[logging_parent]
    )

    parse_translate(translate_parser)
    parse_run_tests(test_runner_parser)
    parse_generate_tests(generate_tests_parser)

    args = parser.parse_args()

    match args.subcommand:
        case 'translate':
            translate(parser, args)
        case 'run-tests':
            run_tests(parser, args)
        case 'generate-tests':
            generate_tests(parser, args)
        case _:
            parser.print_help()


if __name__ == '__main__':
    main()
