import argparse
import os
import sys

from sactor import Sactor
from sactor import logging as sactor_logging
from sactor import utils

logger = sactor_logging.get_logger(__name__)
from sactor.test_generator import ExecutableTestGenerator, TestGeneratorResult
from sactor.test_runner import ExecutableTestRunner, TestRunnerResult


def add_logging_arguments(parser: argparse.ArgumentParser) -> None:
    parser.add_argument(
        '--log-dir',
        dest='log_dir',
        help='Override log directory (default: {result_dir}/logs).'
    )


def _configure_logging_from_args(config, args, *, result_dir: str | None = None):
    return sactor_logging.configure_logging(
        config,
        result_dir=result_dir,
        log_dir_override=getattr(args, 'log_dir', None),
    )


def parse_translate(parser):
    parser.add_argument(
        'input_file',
        type=str,
        nargs='?',
        default=None,
        help='The input C file to translate to Rust. Omit to translate all C files found in compile_commands.json'
    )

    parser.add_argument(
        'test_command_path',
        type=str,
        nargs='?',
        default=None,
        help='The path to the json file containing the test commands, need to follow the format specified in the README'
    )

    parser.add_argument(
        '--test-command-path',
        dest='test_command_override',
        type=str,
        help='Explicitly set the test command json path (overrides the positional argument)'
    )

    parser.add_argument(
        '--type',
        choices=['bin', 'lib'],
        required=True,
        help='Whether the target is a binary program or a library'
    )

    parser.add_argument(
        '--entry-tu-file',
        type=str,
        default=None,
        help='When multiple mains exist, pick the TU (C file) whose main is the entry.'
    )

    parser.add_argument(
        '--config',
        '-c',
        type=str,
        dest='config_file',
        help='The configuration file to use'
    )

    parser.add_argument(
        '--build-dir',
        '-b',
        type=str,
        help='The directory to use for the build process'
    )

    parser.add_argument(
        '--result-dir',
        '-r',
        type=str,
        help='The directory to use for the result process'
    )

    parser.add_argument(
        '--llm-stat',
        '-l',
        type=str,
        help=(
            'The base path for LLM statistics json files; per-stage suffixes '
            '(_unidiomatic/_idiomatic) are added. Default to {result_dir}/llm_stat.json'
        )
    )

    parser.add_argument(
        '--no-verify',
        action='store_true',
        help='Do not verify the generated Rust code'
    )

    parser.add_argument(
        '--unidiomatic-only',
        action='store_true',
        help='Only translate C code into unidiomatic Rust code, skipping the idiomatic translation'
    )

    parser.add_argument(
        '--idiomatic-only',
        action='store_true',
        help='Only translate C code into idiomatic Rust code, skipping the unidiomatic translation'
    )

    parser.add_argument(
        '--continue-run-when-incomplete',
        action='store_true',
        help=('Continue to run idiomatic translation even when not all unidiomatic translation succeeds.\n'
              'Idiomatic translation will only be run for those functions, structs, etc., with existing unidiomatic translation')
    )

    parser.add_argument(
        '--extra-compile-command',
        type=str,
        help='The extra compile command to use to compile the C code', # TODO: dirty implement, remove this later
    )

    parser.add_argument(
        '--executable-object',
        '-e',
        type=str,
        action='append',
        default=None,
        help='Path to an executable object file or link argument; may be specified multiple times for library targets'
    )

    parser.add_argument(
        '--link-args',
        type=str,
        default="",
        help='Additional linker flags to apply when building intermediates (e.g. "-lm -lz").'
    )

    parser.add_argument(
        '--compile-commands-file',
        '-C',
        type=str,
        default="",
        help='The compile commands json file for the project, generated by tools like "scan-build" or "bear"'
    )


def _normalize_executable_object_arg(executable_object):
    if isinstance(executable_object, list):
        executable_object = [item for item in executable_object if item]
        if len(executable_object) == 1:
            return executable_object[0]
        if len(executable_object) == 0:
            return None
        return executable_object
    return executable_object


def parse_run_tests(parser):
    parser.add_argument(
        'test_samples_path',
        type=str,
        help='The path to the test samples output json file'
    )

    parser.add_argument(
        'target',
        help='The target program or library to test'
    )

    parser.add_argument(
        'test_sample_number',
        type=int,
        help='The number (relative to 0) of the test sample to run'
    )

    parser.add_argument(
        '--type',
        choices=['bin', 'lib'],
        required=True,
        help='Whether the target is a binary program or a library'
    )

    parser.add_argument(
        '--config',
        '-c',
        type=str,
        dest='config_file',
        help='The configuration file to use'
    )

    parser.add_argument(
        "--feed-as-args",
        action='store_true',
        default=None,
        help='Only avaliable for binary targets. If set, the test samples will be fed as arguments to the target program. Default set this unless --feed-as-stdin is set.'
    )

    parser.add_argument(
        "--feed-as-stdin",
        action='store_true',
        default=None,
        help='Only avaliable for binary targets. If set, the test samples will be fed to the target program via stdin.'
    )

    parser.add_argument(
        '--save',
        '-s',
        type=str,
        help='The path to save the output json of the test run and the expected output, if the test fails. If not set, the output will not be saved.'
    )


def parse_generate_tests(parser):
    parser.add_argument(
        'input_file',
        type=str,
        help='The input C file to generate tests for'
    )

    parser.add_argument(
        'count',
        type=int,
        help='The number of total test samples expected. This will include the test samples provided in the test_samples_path'
    )

    parser.add_argument(
        '--out-test-sample-path',
        '-os',
        type=str,
        help='The path to the test samples output json file, default to `$PWD/test_task/test_samples.json`'
    )

    parser.add_argument(
        '--out-test-task-path',
        '-ot',
        type=str,
        help='The path to the test task output json file, default to `$PWD/test_task/test_task.json`'
    )

    parser.add_argument(
        '--type',
        choices=['bin', 'lib'],
        required=True,
        help='Whether the target is a binary program or a library'
    )

    parser.add_argument(
        '--config',
        '-c',
        type=str,
        dest='config_file',
        help='The configuration file to use'
    )

    parser.add_argument(
        '--test-samples_path',
        '-s',
        type=str,
        help='The path to the test samples output json file, if any, need to follow the format specified in the README'
    )

    parser.add_argument(
        '--input-document',
        '-i',
        type=str,
        help='The path to the input document file, if any'
    )

    parser.add_argument(
        '--timeout',
        '-t',
        type=int,
        default=60,
        help='The execution timeout in seconds for each test'
    )

    parser.add_argument(
        '--executable',
        '-e',
        type=str,
        default=None,
        help='The path to the executable to test, only required for binary targets. If not set, sactor will try to directly compile the input file'
    )

    parser.add_argument(
        "--feed-as-args",
        action='store_true',
        default=None,
        help='Only avaliable for binary targets. If set, the test samples will be fed as arguments to the target program. Default set this unless --feed-as-stdin is set.'
    )

    parser.add_argument(
        "--feed-as-stdin",
        action='store_true',
        default=None,
        help='Only avaliable for binary targets. If set, the test samples will be fed to the target program via stdin.'
    )


def translate(parser, args):
    if getattr(args, "test_command_override", None):
        args.test_command_path = args.test_command_override

    if not args.test_command_path:
        parser.error('test_command_path is required')

    try:
        exec_obj = _normalize_executable_object_arg(args.executable_object)
        result = Sactor.translate(
            target_type=args.type,
            test_cmd_path=args.test_command_path,
            input_file=args.input_file,
            compile_commands_file=args.compile_commands_file,
            entry_tu_file=args.entry_tu_file,
            result_dir=args.result_dir,
            build_dir=args.build_dir,
            config_file=args.config_file,
            no_verify=args.no_verify,
            unidiomatic_only=args.unidiomatic_only,
            idiomatic_only=args.idiomatic_only,
            continue_run_when_incomplete=args.continue_run_when_incomplete,
            extra_compile_command=args.extra_compile_command,
            executable_object=exec_obj,
            link_args=args.link_args,
            llm_stat=args.llm_stat,
            log_dir_override=getattr(args, 'log_dir', None),
        )
    except (FileNotFoundError, ValueError) as exc:
        parser.error(str(exc))

    if result.any_failed:
        sys.exit(1)


def run_tests(parser, args):
    config = utils.try_load_config(args.config_file)
    _configure_logging_from_args(config, args)

    if args.type == 'lib':
        if args.feed_as_args is not None:
            parser.error('--feed-as-args is only avaliable for binary targets')
        if args.feed_as_stdin is not None:
            parser.error(
                '--feed-as-stdin is only avaliable for binary targets')

    if args.type == 'bin':
        if args.feed_as_args is None and args.feed_as_stdin is None:
            args.feed_as_args = True
        if args.feed_as_args and args.feed_as_stdin:
            parser.error(
                'Only one of --feed-as-args and --feed-as-stdin can be set yet')

    if args.feed_as_args:
        feed_as_args = True
    else:
        assert args.feed_as_stdin
        feed_as_args = False

    if args.type == 'bin':
        target = os.path.abspath(args.target)
        test_runner = ExecutableTestRunner(
            args.test_samples_path,
            target,
            config_path=args.config_file,
            feed_as_arguments=feed_as_args
        )
        result = test_runner.run_test(args.test_sample_number, args.save)
        if result[0] == TestRunnerResult.PASSED:
            logger.info('✅ Test %d passed successfully!', args.test_sample_number, extra={"plain": True})
            sys.exit(0)
        else:
            logger.error('❌ Test %d failed!', args.test_sample_number, extra={"plain": True})
            logger.error('Diff (-actual +expected):', extra={"plain": True})
            if result[1]:
                logger.error('%s', result[1], extra={"plain": True})
            sys.exit(1)

    elif args.type == 'lib':
        raise NotImplementedError('Library test runner not implemented yet')

    else:
        raise ValueError(f'Invalid type: {args.type}')


def generate_tests(parser, args):
    config = utils.try_load_config(args.config_file)
    _configure_logging_from_args(config, args)

    if args.type == 'lib':
        if args.feed_as_args is not None:
            parser.error('--feed-as-args is only avaliable for binary targets')
        if args.feed_as_stdin is not None:
            parser.error(
                '--feed-as-stdin is only avaliable for binary targets')

    if args.type == 'bin':
        if args.feed_as_args is None and args.feed_as_stdin is None:
            args.feed_as_args = True
        if args.feed_as_args and args.feed_as_stdin:
            parser.error(
                'Only one of --feed-as-args and --feed-as-stdin can be set yet')

    if args.feed_as_args:
        feed_as_args = True
    else:
        assert args.feed_as_stdin
        feed_as_args = False

    if args.out_test_task_path and not args.out_test_task_path.endswith('.json'):
        parser.error('The test task output path should end with .json')

    if args.out_test_sample_path and not args.out_test_sample_path.endswith('.json'):
        parser.error('The test samples output path should end with .json')

    if args.type == 'bin':
        test_generator = ExecutableTestGenerator(
            config_path=args.config_file,
            file_path=args.input_file,
            test_samples=[],  # test samples provided from test_samples_path in command line mode
            test_samples_path=args.test_samples_path,
            executable=args.executable,
            input_document=args.input_document,
            feed_as_arguments=feed_as_args,
        )

        result = test_generator.generate_tests(args.count)
        if result == TestGeneratorResult.SUCCESS:
            logger.info('✅ Tests generated successfully!', extra={"plain": True})
            test_generator.create_test_task(
                args.out_test_task_path,
                args.out_test_sample_path
            )
            sys.exit(0)
        else:
            logger.error('❌ Failed to generate tests', extra={"plain": True})
            sys.exit(1)
    elif args.type == 'lib':
        raise NotImplementedError('Library test runner not implemented yet')

    else:
        raise ValueError(f'Invalid type: {args.type}')


def main():
    logging_parent = argparse.ArgumentParser(add_help=False)
    add_logging_arguments(logging_parent)

    parser = argparse.ArgumentParser(
        description='SACToR: Structure-Aware C To Rust Translator',
        parents=[logging_parent]
    )

    subparsers = parser.add_subparsers(
        dest='subcommand',
        description='valid subcommands for SACToR to work in different modes',
        help='Use one of these subcommands followed by -h for additional help',
        required=True
    )

    translate_parser = subparsers.add_parser(
        'translate',
        help='Translate C code into Rust code',
        parents=[logging_parent]
    )

    test_runner_parser = subparsers.add_parser(
        'run-tests',
        help='Run tests on the target program or library',
        parents=[logging_parent]
    )

    generate_tests_parser = subparsers.add_parser(
        'generate-tests',
        help='Generate tests for the target program or library',
        parents=[logging_parent]
    )

    parse_translate(translate_parser)
    parse_run_tests(test_runner_parser)
    parse_generate_tests(generate_tests_parser)

    args = parser.parse_args()

    match args.subcommand:
        case 'translate':
            translate(parser, args)
        case 'run-tests':
            run_tests(parser, args)
        case 'generate-tests':
            generate_tests(parser, args)
        case _:
            parser.print_help()


if __name__ == '__main__':
    main()
